#include <stdio.h>

/* testing bitwise operators, see sec 2.9, p48 */
/* includes function getbits() given on p49 */

unsigned getbits(unsigned x, int p, int n) ;


int main()
{ 
  int i, y1;

  unsigned int x = 279; /* = 2^8 + 13 */
  x = x & 0177; 
  printf("%u\n",x);
  x = ~0;
  printf("%u\n",x);
  x = 269;
  x = ~x;
  printf("%u\n",x);
  int y = 25;
  printf("%d\n",y);
  y = ~y;
  printf("%d\n",y);
  /* ~ appears to be flipping sign then subtracting 1, 
     not what I expected */

  /* so far my expectations are only met for unsigned int */

  /* let's try out getbits and see if we can clarify things */
  y = 5;
  y1 = getbits(~y,25,5);
  printf("%d\n",y1);

  unsigned x1;
  x = 27;
  x1 = getbits(x,5,6);
  printf("%u\n",x1);

  /* two's complement!! negative ints are the opposite and offset by 1 */
  y = 5;
  printf("%d\n",~y);

  /* play with << and >> */
  printf("play with << and >>\n");
  /* what does my compiler do with signed? */
  x = 24;
  x = x >> 3;
  printf("%u\n",x);

  y = -24;
  y = y >> 3;
  printf("%u\n",y);
  /* appears to be doing "logical shift", 
     leaving sign bit 0 for >> */

  /* 
  
}


/*getbits: get n bits from position p */
unsigned getbits(unsigned x, int p, int n) 
/* n and p dont have to be positive?!? test that */
{
  return (x >> (p+1-n)) & ~(~0 << n);
}
